//
//  TimelineViewController.swift
//  SwiftTwitter
//
//  Created by Matheus Lima on 15/04/19.
//  Copyright (c) 2019 Matheus Lima. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol TimelineDisplayLogic: class {
    func displayUser(viewModel: Timeline.GetUser.ViewModel)
    func displayUserTimeline(viewModel: Timeline.FetchUserTimeline.ViewModel)
    func displayUserTimelineError(viewModel: Timeline.FetchUserTimeline.ViewModel)
    func stopLoading()
}

class TimelineViewController: UIViewController {
    
    // MARK: - Outlets
    
    @IBOutlet weak var scrollView: UIScrollView!
    @IBOutlet weak var tableView: UITableView!
    @IBOutlet weak var tableViewActivityIndicator: UIActivityIndicatorView!
    @IBOutlet weak var headerArrowDownIcon: UIImageView!
    @IBOutlet weak var avatarImage: UIImageView!
    @IBOutlet weak var headerView: UIView!
    @IBOutlet weak var headerActivityIndicator: UIActivityIndicatorView!
    @IBOutlet weak var headerImageView: UIImageView!
    @IBOutlet weak var headerNameLabel: UILabel!
    @IBOutlet weak var headerTweetsCountLabel: UILabel!
    @IBOutlet weak var nameLabel: UILabel!
    @IBOutlet weak var usernameLabel: UILabel!
    @IBOutlet weak var descriptionLabel: UILabel!
    @IBOutlet weak var joinedDateLabel: UILabel!
    @IBOutlet weak var followingCountLabel: UILabel!
    @IBOutlet weak var followersCountLabel: UILabel!
    @IBOutlet weak var backButton: BackButton!
    
    // MARK: - UI elements and Calculation of Constants
    
    lazy var blurEffectView: UIVisualEffectView = {
        let blurEffectView = UIVisualEffectView(effect: UIBlurEffect(style: .dark))
        blurEffectView.frame = headerImageView.bounds
        blurEffectView.alpha = 0
        headerImageView.addSubview(blurEffectView)
        return blurEffectView
    }()
    lazy var offsetHeaderStop: CGFloat = {
        // At this offset the headerView stops its transformations
        return headerView.bounds.height
            - CGFloat(Constants.Timeline.StickyHeaderHeight)
            - CGFloat(Constants.StatusBarHeight)
    }()
    lazy var offsetLabelHeader: CGFloat = {
        // At this offset the nameLabel reaches the Bottom of headerView
        return nameLabel.frame.origin.y - offsetHeaderStop + nameLabel.frame.height - 3
    }()
    lazy var distanceLabelHeader: CGFloat = {
        // The distance between the bottom of the headerView and the top of the headerNameLabel
        return nameLabel.bounds.height + 18
    }()
    
    // MARK: - Properties
    
    var interactor: TimelineBusinessLogic?
    var router: (NSObjectProtocol & TimelineRoutingLogic & TimelineDataPassing)?
    private var displayedTweets: [Timeline.FetchUserTimeline.ViewModel.DisplayedTweet] = []

    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup() {
        let viewController = self
        let interactor = TimelineInteractor()
        let presenter = TimelinePresenter()
        let router = TimelineRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    
    private func prepareUI() {
        navigationController?.setNavigationBarHidden(true, animated: false)
        backButton.layer.zPosition = 3
    }
    
    // MARK: Routing
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        prepareUI()
        fetchUserTimeline()
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        self.setNeedsStatusBarAppearanceUpdate()
        getUser()
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        navigationController?.setNavigationBarHidden(false, animated: false)
    }
    
    override var preferredStatusBarStyle: UIStatusBarStyle {
        return .lightContent
    }
    
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        tableView.sizeHeaderToFit()
    }
    
    private func loadUI() {
        tableView.reloadData()
    }
    
    // MARK: Get User
    
    private func getUser() {
        let request = Timeline.GetUser.Request()
        interactor?.getUser(request: request)
    }
    
    // MARK: Fetch User Timeline
    
    private func fetchUserTimeline() {
        let request = Timeline.FetchUserTimeline.Request()
        interactor?.fetchUserTimeline(request: request)
    }
    
    private func refreshUserTimeline() {
        interactor?.refreshUserTimeline()
    }
    
    // MARK: - Actions
    
    @IBAction func backAction(_ sender: Any) {
        navigationController?.popViewController(animated: true)
    }
}

// MARK: - TimelineDisplayLogic

extension TimelineViewController: TimelineDisplayLogic {
    func displayUserTimeline(viewModel: Timeline.FetchUserTimeline.ViewModel) {
        guard let displayedTweets = viewModel.displayedTweets else { return }
        
        self.displayedTweets = displayedTweets
        loadUI()
    }
    
    func displayUser(viewModel: Timeline.GetUser.ViewModel) {
        let displayedUser = viewModel.displayedUser
        
        headerImageView.backgroundColor = displayedUser.profileBackgroundColor
        headerNameLabel.text = displayedUser.name
        headerTweetsCountLabel.text = displayedUser.tweetsCount
        nameLabel.text = displayedUser.name
        usernameLabel.text = displayedUser.username
        descriptionLabel.text = displayedUser.description
        joinedDateLabel.text = displayedUser.joinedDate
        followingCountLabel.text = displayedUser.followingCount
        followersCountLabel.text = displayedUser.followersCount
        avatarImage.kf.setImage(with: displayedUser.avatarURL)
        headerImageView.kf.setImage(with: displayedUser.coverURL)
    }
    
    func displayUserTimelineError(viewModel: Timeline.FetchUserTimeline.ViewModel) {
        guard let errorMessage = viewModel.error else { return }
        showInfo(withTitle: "Ops!", withMessage: errorMessage)
    }
    
    func stopLoading() {
        tableViewActivityIndicator.stopAnimating()
        headerActivityIndicator.stopAnimating()
        resetRotationHeaderArrowDown()
    }
}

// MARK: - UITableViewDataSource

extension TimelineViewController: UITableViewDataSource {
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return displayedTweets.count
    }

    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let displayedTweet = displayedTweets[indexPath.row]
        let cell = Bundle.main.loadNibNamed("TweetTableViewCell", owner: self, options: nil)?.first as! TweetTableViewCell
        
        cell.profileImageView.kf.setImage(with: displayedTweet.authorProfileImageUrl)
        cell.profileImageView.kf.indicatorType = .activity
        cell.nameLabel.text = displayedTweet.authorName
        cell.usernameLabel.text = displayedTweet.authorUsername
        cell.dateLabel.text = displayedTweet.date
        cell.replyToUsernameLabel.attributedText = displayedTweet.replyToUsername
        cell.fullTextLabel.text = displayedTweet.text
        cell.replyCountLabel.text = displayedTweet.replyCount
        cell.retweetCountLabel.text = displayedTweet.retweetCount
        cell.favoriteCountLabel.text = displayedTweet.favoriteCount
        
        return cell
    }
}

// MARK: - UITableViewDelegate

extension TimelineViewController: UITableViewDelegate {
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        tableView.deselectRow(at: indexPath, animated: true)
    }
}

// MARK: - UIScrollViewDelegate

extension TimelineViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        applyUITransformations(with: scrollView)
    }
    
    func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {
        let offsetY = scrollView.contentOffset.y
        let alphaFactor = getAlphaFactor(with: scrollView)
        // Pull down
        if offsetY < 0, alphaFactor == 1.0 {
            refreshUserTimeline()
            rotateHeaderArrowDown()
        }
    }
    
    // MARK: Convenience ScrollView methods
    
    private func rotateHeaderArrowDown() {
        UIView.animate(withDuration: 0.3) { [weak self] in
            self?.headerArrowDownIcon.transform = CGAffineTransform(rotationAngle: CGFloat(Double.pi))
            self?.headerArrowDownIcon.alpha = 0
            self?.headerActivityIndicator.startAnimating()
            self?.headerActivityIndicator.alpha = 1
        }
    }
    
    private func resetRotationHeaderArrowDown() {
        headerArrowDownIcon.transform = CGAffineTransform(rotationAngle: 0)
        headerActivityIndicator.alpha = 0
    }
    
    private func getHeaderScaleFactor(with scrollView: UIScrollView) -> CGFloat {
        return (-scrollView.contentOffset.y / headerView.bounds.height) + 1.0
    }
    
    private func getAlphaFactor(with scrollView: UIScrollView) -> CGFloat {
        let headerScaleFactor = getHeaderScaleFactor(with: scrollView)
        return min(1.0, (abs(headerScaleFactor) - 1.0) * 2.5)
    }
    
    private func getHeaderSizeVariation(with scrollView: UIScrollView) -> CGFloat {
        let headerScaleFactor = getHeaderScaleFactor(with: scrollView)
        return ((headerView.bounds.height * headerScaleFactor) - headerView.bounds.height) / 2.0
    }
    
    private func applyUITransformations(with scrollView: UIScrollView) {
        let offsetY = scrollView.contentOffset.y
        var avatarTransform = CATransform3DIdentity
        var headerTransform = CATransform3DIdentity
        
        // Pull down
        if offsetY <= 0 {
            let headerScaleFactor = getHeaderScaleFactor(with: scrollView)
            let headerSizeVariation = getHeaderSizeVariation(with: scrollView)
            let alphaFactor = getAlphaFactor(with: scrollView)
            
            headerTransform = CATransform3DTranslate(headerTransform, 0, headerSizeVariation, 0)
            headerTransform = CATransform3DScale(headerTransform, headerScaleFactor, headerScaleFactor, 0)
            blurEffectView.alpha = alphaFactor
            
            // Refreshing
            if !headerActivityIndicator.isAnimating {
                headerArrowDownIcon.alpha = alphaFactor
            }
        }
        // Scroll UP/Down
        else {
            // Header
            headerTransform = CATransform3DTranslate(
                headerTransform, 0, max(-offsetHeaderStop, -offsetY), 0
            )
            
            // Label
            let labelTransform = CATransform3DMakeTranslation(0, max(-distanceLabelHeader, offsetLabelHeader - offsetY), 0)
            headerNameLabel.layer.transform = labelTransform
            headerTweetsCountLabel.layer.transform = labelTransform
            
            // Blur
            blurEffectView.alpha = min(1.0, (offsetY - offsetLabelHeader)/distanceLabelHeader)
            
            // Avatar
            let avatarScaleFactor = (min(offsetHeaderStop, offsetY)) / avatarImage.bounds.height / 2 // Slow down the animation
            let avatarSizeVariation = ((avatarImage.bounds.height * (1.0 + avatarScaleFactor)) - avatarImage.bounds.height) / 2.0
            avatarTransform = CATransform3DTranslate(avatarTransform, 0, avatarSizeVariation, 0)
            avatarTransform = CATransform3DScale(avatarTransform, 1.0 - avatarScaleFactor, 1.0 - avatarScaleFactor, 0)
        }
        
        
        
        if offsetY <= offsetHeaderStop {
            if avatarImage.layer.zPosition < headerView.layer.zPosition {
                headerView.layer.zPosition = 0
            }
        } else {
            if avatarImage.layer.zPosition >= headerView.layer.zPosition {
                headerView.layer.zPosition = 2
            }
        }
        
        // Apply Transformations
        headerView.layer.transform = headerTransform
        avatarImage.layer.transform = avatarTransform
    }
}
